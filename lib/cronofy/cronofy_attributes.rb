module Cronofy
  module CronofyAttributes
    def self.included(klass)
      klass.class_eval do
        def self.event_time_attribute(*names)
          names.each do |name|
            define_method(name) { EventTime.coerce(instance_variable_get("@#{name}")) }
            define_method("#{name}=") do |value|
              instance_variable_set("@#{name}", EventTime.coerce(value))
            end

            setter_event_class = Utils.set_type_constant("#{self.name}#{Utils.camelcase(name)}Set")

            setter_event_class.class_eval <<-RUBY, __FILE__, __LINE__ + 1
            include EntityStore::Event

            attr_accessor :by
            time_attribute :at

            define_method(name) { EventTime.coerce(instance_variable_get("@#{name}")) }
            define_method("#{name}=") do |value|
            instance_variable_set("@#{name}", EventTime.coerce(value))
          end

            def apply(entity)
            entity.send(\"#{name}=\", instance_variable_get("@#{name}"))
          end
            RUBY

            define_method("set_#{name}") do |by, at, value|
              return if value == send(name)
              set_event = setter_event_class.new(by: by.id, at: at, name => value)
              record_event set_event
            end
          end
        end
      end
    end
  end
end

# Support class names incorrectly generated by a previous event_time_attribute
# implementation.
class ClassScheduledStartTimeSet
  include EntityStore::Event

  attr_accessor :by
  time_attribute :at

  def scheduled_start_time
    EventTime.coerce(@scheduled_start_time)
  end

  def scheduled_start_time=(value)
    @scheduled_start_time = EventTime.coerce(value)
  end

  def apply(entity)
    entity.scheduled_start_time = @scheduled_start_time
  end
end
